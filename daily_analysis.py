import asyncio
import os
from typing import Dict, List

from convert_api import get_balances, get_available_to_tokens, get_quote
from convert_logger import logger
from convert_model import predict
from utils_dev3 import save_json


async def fetch_quotes(from_token: str, amount: float) -> List[Dict[str, float]]:
    """Fetch quotes for all available to_tokens for a given from_token and run prediction."""
    predictions: List[Dict[str, float]] = []
    try:
        to_tokens = await asyncio.to_thread(get_available_to_tokens, from_token)
    except Exception as exc:
        logger.warning(f"[dev3] ‚ùå get_available_to_tokens –ø–æ–º–∏–ª–∫–∞ –¥–ª—è {from_token}: {exc}")
        return predictions

    if not to_tokens:
        logger.warning(f"[dev3] ‚ö†Ô∏è –ù–µ–º–∞—î –¥–æ—Å—Ç—É–ø–Ω–∏—Ö to_token –¥–ª—è {from_token}")
    else:
        logger.info(f"[dev3] üîÑ {from_token}: –∑–Ω–∞–π–¥–µ–Ω–æ {len(to_tokens)} TO —Ç–æ–∫–µ–Ω—ñ–≤")

    for to_token in to_tokens:
        try:
            quote = await asyncio.to_thread(get_quote, from_token, to_token, amount)
        except Exception as exc:
            logger.warning(f"[dev3] ‚ùå get_quote –ø–æ–º–∏–ª–∫–∞ –¥–ª—è {from_token} ‚Üí {to_token}: {exc}")
            continue

        logger.info(f"[dev3] üîç Quote {from_token} ‚Üí {to_token}: {quote}")

        if not isinstance(quote, dict) or "ratio" not in quote:
            continue

        ratio = float(quote["ratio"])
        inverse_ratio = 1 / ratio if ratio != 0 else 0.0

        try:
            logger.info(f"[dev3] ü§ñ predict() –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è –¥–ª—è {from_token} ‚Üí {to_token} –∑ –¥–∞–Ω–∏–º–∏: {quote}")
            expected_profit, prob_up, score = predict(
                from_token,
                to_token,
                {"ratio": ratio, "inverseRatio": inverse_ratio},
            )
        except Exception as exc:
            logger.warning(f"[dev3] ‚ùå –ü–æ–º–∏–ª–∫–∞ –≤ predict() –¥–ª—è {from_token} ‚Üí {to_token}: {exc}")
            continue

        predictions.append({
            "from_token": from_token,
            "to_token": to_token,
            "ratio": ratio,
            "inverseRatio": inverse_ratio,
            "expected_profit": expected_profit,
            "prob_up": prob_up,
            "score": score,
        })

    logger.info(f"[dev3] ‚úÖ –ü—Ä–æ–≥–Ω–æ–∑—ñ–≤ –¥–ª—è {from_token}: {len(predictions)}")
    return predictions


async def gather_predictions() -> List[Dict[str, float]]:
    """Collect predictions for all tokens from account balances."""
    try:
        balances = await asyncio.to_thread(get_balances)
    except Exception as exc:
        logger.warning(f"[dev3] ‚ùå get_balances –ø–æ–º–∏–ª–∫–∞: {exc}")
        return []

    logger.info(f"[dev3] üîÑ –û—Ç—Ä–∏–º–∞–Ω–æ {len(balances)} —Ç–æ–∫–µ–Ω—ñ–≤ –∑ –±–∞–ª–∞–Ω—Å—É")

    tasks = [fetch_quotes(token, amount) for token, amount in balances.items()]
    results = await asyncio.gather(*tasks)

    predictions: List[Dict[str, float]] = []
    for items in results:
        predictions.extend(items)

    logger.info(f"[dev3] ‚úÖ –ó–∞–≥–∞–ª–æ–º –æ—Ç—Ä–∏–º–∞–Ω–æ {len(predictions)} –ø—Ä–æ–≥–Ω–æ–∑—ñ–≤")
    return predictions


async def main() -> None:
    predictions = await gather_predictions()

    os.makedirs("logs", exist_ok=True)
    await asyncio.to_thread(save_json, os.path.join("logs", "predictions.json"), predictions)

    sorted_tokens = sorted(predictions, key=lambda x: x["score"], reverse=True)
    top_tokens = sorted_tokens[:5]
    if not top_tokens:
        logger.warning("[dev3] ‚ùå top_tokens.json –ø–æ—Ä–æ–∂–Ω—ñ–π ‚Äî –≤—ñ–¥—Å—É—Ç–Ω—ñ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ñ –ø—Ä–æ–≥–Ω–æ–∑–∏")
    await asyncio.to_thread(save_json, "top_tokens.json", top_tokens)

    logger.info(f"[dev3] ‚úÖ –ê–Ω–∞–ª—ñ–∑ –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –°—Ç–≤–æ—Ä–µ–Ω–æ top_tokens.json –∑ {len(top_tokens)} –∑–∞–ø–∏—Å–∞–º–∏.")


if __name__ == "__main__":
    asyncio.run(main())
