"""Low level helpers for Binance Spot/SAPI Convert endpoints.

This module focuses on correctly signing and sending requests to Binance.
It implements a minimal retry policy with exponential backoff. Only
``application/x-www-form-urlencoded`` payloads are used for POST requests in
order to comply with Binance requirements.

The functions exposed here are intentionally lightweight so they can be
mocked easily in tests.  They **must not** log or expose API secrets.
"""

from __future__ import annotations

import hashlib
import hmac
import importlib.util
import logging
import os
import math
from decimal import Decimal, ROUND_DOWN

def _norm(v):
    x=float(v)
    import math as _m
    if not _m.isfinite(x) or x<=0:
        raise ValueError("fromAmount/toAmount must be positive finite")
    t=f"{x:.8f}".rstrip("0").rstrip(".")
    return t or "0"

import pathlib
import random
import time
from typing import Any, Dict, List, Optional, Set

import re

_ASSET_FRACTION_CACHE = {}

# === FIXUP 2025-09-06: Binance Convert (safe overrides) ===
from typing import Any, Dict, List
from decimal import Decimal, ROUND_DOWN

_ASSET_FRACTION_CACHE: Dict[str, int] = {}

def _get_asset_fraction(asset: str) -> int:
    """Per-asset decimal precision (fraction) via /sapi/v1/convert/assetInfo."""
    if not asset:
        return 8
    if asset in _ASSET_FRACTION_CACHE:
        return _ASSET_FRACTION_CACHE[asset]
    data = _request("GET", "/sapi/v1/convert/assetInfo", None)
    items = data if isinstance(data, list) else (data.get("assetInfo") or data)
    frac = None
    for it in (items or []):
        a = it.get("asset") or it.get("fromAsset")
        if a == asset:
            frac = it.get("fraction")
            break
    if not isinstance(frac, int):
        frac = 8
    _ASSET_FRACTION_CACHE[asset] = frac
    return frac

def _format_amount_for_asset(amount, asset: str) -> str:
    """Format amount with ROUND_DOWN to asset's fraction."""
    q = Decimal(str(amount))
    frac = _get_asset_fraction(asset)
    quant = Decimal(1).scaleb(-frac)  # 10^-frac
    return format(q.quantize(quant, rounding=ROUND_DOWN), 'f')

def get_convert_pairs() -> List[Dict[str, Any]]:
    """List convert pairs via /sapi/v1/convert/exchangeInfo."""
    return _request("GET", "/sapi/v1/convert/exchangeInfo", None)

def get_available_to_tokens(from_asset: str) -> List[str]:
    """All toAsset for a given from_asset (letters only, len>=2, no self-pairs)."""
    data = get_convert_pairs()
    pairs = data if isinstance(data, list) else (data.get("data") or data)
    outs: List[str] = []
    for it in (pairs or []):
        fa = it.get("fromAsset")
        ta = it.get("toAsset")
        if fa == from_asset and ta and ta.isalpha() and len(ta) >= 2 and ta != fa:
            outs.append(ta)
    return sorted(set(outs))

def get_quote_with_id(from_asset: str, to_asset: str, from_amount=None, to_amount=None,
                      walletType=None, validTime=None, recvWindow=None) -> Dict[str, Any]:
    """POST /sapi/v1/convert/getQuote â€” exactly one of from_amount or to_amount."""
    if (from_amount is None) == (to_amount is None):
        raise ValueError("Provide exactly one of from_amount or to_amount")
    params: Dict[str, Any] = {"fromAsset": from_asset, "toAsset": to_asset, "recvWindow": recvWindow}
    if from_amount is not None:
        params["fromAmount"] = _format_amount_for_asset(from_amount, from_asset)
    if to_amount is not None:
        params["toAmount"] = _format_amount_for_asset(to_amount, to_asset)
    if walletType: params["walletType"] = walletType
    if validTime:  params["validTime"]  = validTime
    return _request("POST", "/sapi/v1/convert/getQuote", params)

def get_quote(from_token: str, to_token: str, amount: float) -> Dict[str, Any]:
    """Compat wrapper."""
    if amount is None:
        raise ValueError("amount is required")
    return get_quote_with_id(from_token, to_token, from_amount=amount)
# === END FIXUP ===
