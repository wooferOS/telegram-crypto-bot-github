
import subprocess
from dotenv import load_dotenv
from decimal import Decimal, ROUND_DOWN
from daily_analysis import generate_zarobyty_report
from binance_api import get_binance_balances, get_symbol_price
from datetime import datetime, timedelta
import pytz

load_dotenv("/root/.env")
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
CHAT_ID = os.getenv("CHAT_ID")

def send_telegram_message(message: str):
    subprocess.run([
        "curl", "-s", "-X", "POST",
        f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage",
        "-d", f"chat_id={CHAT_ID}",
        "-d", f"text={message}"
    ])

def format_number(num, digits=8):
    d = Decimal(str(num)).quantize(Decimal("1." + "0" * digits), rounding=ROUND_DOWN)
    return format(d.normalize(), 'f')

if __name__ == "__main__":
    balances = get_binance_balances()
    report, sell_signals, buy_signals, _ = generate_zarobyty_report(horizon="75m", balances=balances)

    balance_lines = []
    for symbol, amount in balances.items():
        if amount > 0:
            balance_lines.append(f"- {symbol}: {format_number(amount)}")

    # ‚úÖ TOP 3 BUY —Ç–æ–∫–µ–Ω–∏
    top_buys = sorted(buy_signals, key=lambda x: x.get("expected_profit", 0), reverse=True)[:3]
    valid_top_buys = [b for b in top_buys if get_symbol_price(b.get("symbol", "") or "")]
    total_expected_profit = sum(
        Decimal(str(b.get("expected_profit", 0)))
        for b in valid_top_buys if b.get("expected_profit", 0) > 0
    )

    # ‚úÖ FROM —Ç–æ–∫–µ–Ω–∏ ‚Äî –≤—Å—ñ –∑ –±–∞–ª–∞–Ω—Å—É, –∫—Ä—ñ–º USDT
    all_from_tokens = [(token, amount) for token, amount in balances.items() if token != "USDT" and amount > 0]
    top_from_tokens = sorted(all_from_tokens, key=lambda x: get_symbol_price(x[0] + "USDT") or 0, reverse=True)

    # ‚úÖ –û–±–º–µ–∂–∏—Ç–∏ –¥–æ 4
    top_from_tokens = top_from_tokens[:4]

    convert_lines = []
    total_profit = Decimal("0")
    grouped_lines = {}

    for from_token, amount in top_from_tokens:
        price_from = Decimal(str(get_symbol_price(from_token + "USDT") or "0"))
        if price_from == 0 or amount == 0 or not valid_top_buys or total_expected_profit == 0:
            continue

        # ‚úÖ –Ω–∞–π–∫—Ä–∞—â–∏–π BUY-—Ç–æ–∫–µ–Ω –∑–∞ expected_profit
        best_buy = max(valid_top_buys, key=lambda b: Decimal(str(b.get("expected_profit", 0))))
        to_token = best_buy.get("symbol")
        if from_token == to_token or from_token in to_token:
            continue

        expected_profit = Decimal(str(best_buy.get("expected_profit", 0)))
        portion = (Decimal(str(amount)) * Decimal("0.9")) * expected_profit / total_expected_profit
        usdt_equiv = (portion * price_from).quantize(Decimal("0.0001"))
        total_profit += usdt_equiv

        line = (
            f"{from_token} ‚Üí {to_token}\n"
            f"–ö—ñ–ª—å–∫—ñ—Å—Ç—å: **{format_number(portion)}** {from_token}\n"
            f"‚âà {format_number(usdt_equiv, 4)} USDT"
        )
        grouped_lines.setdefault(from_token, []).append(line)

    for token, lines in grouped_lines.items():
        convert_lines.append(f"üî∏ {token}")
        convert_lines.extend(lines)

    future_time = datetime.now(pytz.timezone("Europe/Kyiv")) + timedelta(minutes=75)
    future_time_str = future_time.strftime("%H:%M")

    message = "üßæ –ë–∞–ª–∞–Ω—Å –Ω–∞ –∑–∞—Ä–∞–∑:\n" + "\n".join(balance_lines)
    message += "\n\nüîÑ –ü—Ä–æ–ø–æ–∑–∏—Ü—ñ—è –¥–ª—è —Ä—É—á–Ω–æ—ó –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—ó:\n" + "\n".join(convert_lines)
    message += f"\n\nüìà –û—á—ñ–∫—É–≤–∞–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫ –¥–æ {future_time_str}:\n- {format_number(total_profit, 4)} USDT"
    message += "\n\n‚è± –ó—Ä–æ–±–∏ —Ä—É—á–Ω—É –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—é —á–µ—Ä–µ–∑ Binance Convert"

    send_telegram_message(message)
