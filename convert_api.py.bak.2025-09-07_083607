"""Low level helpers for Binance Spot/SAPI Convert endpoints.

This module focuses on correctly signing and sending requests to Binance.
It implements a minimal retry policy with exponential backoff. Only
``application/x-www-form-urlencoded`` payloads are used for POST requests in
order to comply with Binance requirements.

The functions exposed here are intentionally lightweight so they can be
mocked easily in tests.  They **must not** log or expose API secrets.
"""

from __future__ import annotations

import hashlib
import hmac
import importlib.util
import logging
import os
import pathlib
import random
import time
from typing import Any, Dict, List, Optional, Set

import requests
from requests.adapters import HTTPAdapter
from urllib3.util import Retry

_DEF_CFG = "/root/telegram-crypto-bot-github/config_dev3.py"


def load_binance_credentials() -> tuple[str, str]:
    key = os.getenv("BINANCE_API_KEY")
    sec = os.getenv("BINANCE_API_SECRET")

    if not (key and sec):
        cfg_path = os.getenv("DEV_CONFIG_PATH", _DEF_CFG)
        if pathlib.Path(cfg_path).is_file():
            spec = importlib.util.spec_from_file_location("cfg", cfg_path)
            m = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(m)  # noqa: S301 - trusted local file
            key = getattr(m, "BINANCE_API_KEY", None)
            sec = getattr(m, "BINANCE_API_SECRET", None)

    if not key or not sec:
        raise RuntimeError(
            "Binance credentials not found: set BINANCE_API_* or provide config_dev3.py"
        )

    return key, sec


BINANCE_API_KEY, BINANCE_API_SECRET = load_binance_credentials()

from utils_dev3 import get_current_timestamp
from quote_counter import increment_quote_usage


BASE_URL = os.getenv("BINANCE_API_BASE", "https://api.binance.com")
DEFAULT_RECV_WINDOW = int(os.getenv("BINANCE_RECV_WINDOW", "5000"))

# requests session with a tiny retry just for connection errors.  Rate limit
# handling is done manually below.
_session = requests.Session()
_retry = Retry(total=3, backoff_factor=0, status_forcelist=(418, 429))
_session.mount("https://", HTTPAdapter(max_retries=_retry))
logger = logging.getLogger(__name__)

# cache for supported Convert pairs
_supported_pairs_cache: Optional[Set[str]] = None
_pairs_cache_time: float = 0
PAIRS_TTL = 1800  # seconds

# cache for exchangeInfo responses
_exchange_info_cache: Optional[Dict[str, Any]] = None
_exchange_info_time: float = 0

# offset between local time and Binance server time
_time_offset_ms = 0
# whether we already synchronised time with Binance
_time_synced = False

# quoteIds already processed via acceptQuote
_accepted_quotes: Set[str] = set()


class ClockSkewError(Exception):
    """Raised when Binance reports timestamp drift (-1021)."""


def _current_timestamp() -> int:
    """Return current timestamp in milliseconds including server offset."""
    return get_current_timestamp() + _time_offset_ms


def _sync_time() -> None:
    """Synchronise local clock with Binance server time."""
    global _time_offset_ms, _time_synced
    try:
        resp = _session.get(f"{BASE_URL}/api/v3/time", timeout=10)
        server_time = int(resp.json().get("serverTime", 0))
        _time_offset_ms = server_time - get_current_timestamp()
    except Exception:  # pragma: no cover - network
        _time_offset_ms = 0
    _time_synced = True


def _sign(params: Dict[str, Any]) -> Dict[str, Any]:
    """Sign parameters using HMAC-SHA256.

    ``timestamp`` and default ``recvWindow`` are appended *after* existing
    parameters so that the order of keys matches the actual payload sent to
    Binance.
    """

    params = params.copy()
    params.setdefault("recvWindow", DEFAULT_RECV_WINDOW)
    params["timestamp"] = _current_timestamp()
    query = "&".join(f"{k}={v}" for k, v in params.items())
    signature = hmac.new(
        BINANCE_API_SECRET.encode(), query.encode(), hashlib.sha256
    ).hexdigest()
    params["signature"] = signature
    return params


def _headers() -> Dict[str, str]:
    return {
        "X-MBX-APIKEY": BINANCE_API_KEY,
        "Content-Type": "application/x-www-form-urlencoded",
    }


def _backoff(attempt: int) -> float:
    """Exponential backoff with jitter."""
    base = 0.5 * (2 ** (attempt - 1))
    return min(base, 30.0) + random.uniform(0, 0.25)


def _request(method: str, path: str, params: Dict[str, Any], *, signed: bool = True) -> Dict[str, Any]:
    """Send a request to Binance with optional signing and retry."""

    url = f"{BASE_URL}{path}"
    tried_time_sync = False
    if signed and not _time_synced:
        _sync_time()
    for attempt in range(1, 6):
        payload = _sign(params) if signed else params
        headers = _headers() if signed else None
        try:
            if method == "GET":
                resp = _session.get(url, params=payload, headers=headers, timeout=10)
            else:
                resp = _session.post(url, data=payload, headers=headers, timeout=10)
        except requests.RequestException:  # pragma: no cover - network
            if attempt >= 5:
                raise
            time.sleep(_backoff(attempt))
            continue

        if resp.status_code >= 500 or resp.status_code in (418, 429):
            retry_after = resp.headers.get("Retry-After")
            delay = float(retry_after) if retry_after else _backoff(attempt)
            time.sleep(delay)
            continue

        data = resp.json()

        if isinstance(data, dict):
            code = data.get("code")
            if code is not None:
                logger.warning("Binance error %s: %s", code, data.get("msg"))
            if code == -1021:
                time.sleep(_backoff(attempt))
                if not tried_time_sync:
                    tried_time_sync = True
                    _sync_time()
                continue
            if code == -1022:
                raise ValueError("Signature for this request is not valid")
            if code in (-1102, -1103):
                raise ValueError("Missing or invalid parameter")
            if code == -2015:
                raise PermissionError("Invalid API-key or permissions")
            if code in (-1003, 345239):
                time.sleep(_backoff(attempt))
                continue

        return data

    raise RuntimeError("Request failed after retries")


def get_balances() -> Dict[str, float]:
    # PAPER fallback: allow specifying balances via env without hitting API
    if os.getenv("PAPER", "0") == "1":
        raw = os.getenv("PAPER_BALANCES", "")
        balances: Dict[str, float] = {}
        for part in raw.split(","):
            if "=" in part:
                k, v = part.split("=", 1)
                try:
                    balances[k.strip()] = float(v)
                except ValueError:
                    pass
        if balances:
            return balances

    data = _request("GET", "/api/v3/account", {})
    balances = {}
    for bal in data.get("balances", []):
        total = float(bal.get("free", 0)) + float(bal.get("locked", 0))
        if total > 0:
            balances[bal["asset"]] = total
    return balances


def exchange_info(**params: Any) -> Dict[str, Any]:
    """Return Convert exchange information (public, cached)."""

    global _exchange_info_cache, _exchange_info_time
    if not params:
        now = time.time()
        if _exchange_info_cache and now - _exchange_info_time < PAIRS_TTL:
            return _exchange_info_cache

    data = _request("GET", "/sapi/v1/convert/exchangeInfo", params, signed=False)

    if not params:
        _exchange_info_cache = data
        _exchange_info_time = time.time()
    return data


def get_available_to_tokens(from_token: str) -> List[str]:
    if os.getenv("PAPER", "0") == "1":
        sample = ["USDT", "BTC", "ETH", "SOL"]
        return [t for t in sample if t != from_token]

    data = exchange_info(fromAsset=from_token)
    if isinstance(data, list):
        data = {"toAssetList": data}
    return [item.get("toAsset") for item in data.get("toAssetList", [])]


def get_quote_with_id(
    from_asset: str,
    to_asset: str,
    from_amount: Optional[float] = None,
    to_amount: Optional[float] = None,
    walletType: Optional[str] = None,
    recvWindow: int = DEFAULT_RECV_WINDOW,
) -> Dict[str, Any]:
    """Request a quote. Exactly one of ``from_amount`` or ``to_amount`` must be set."""

    if (from_amount is None) == (to_amount is None):
        raise ValueError("Provide exactly one of from_amount or to_amount")

    increment_quote_usage()
    params = {
        "fromAsset": from_asset,
        "toAsset": to_asset,
    }
    if from_amount is not None:
        params["fromAmount"] = from_amount
    if to_amount is not None:
        params["toAmount"] = to_amount
    if walletType:
        params["walletType"] = walletType
    params["recvWindow"] = recvWindow
    return _request("POST", "/sapi/v1/convert/getQuote", params)


def get_quote(from_token: str, to_token: str, amount: float) -> Dict[str, Any]:
    """Backward compatible wrapper with PAPER stub."""
    if os.getenv("PAPER", "0") == "1":
        import hashlib, uuid

        key = f"{from_token}->{to_token}".encode()
        h = int(hashlib.sha256(key).hexdigest(), 16)
        drift = ((h % 2001) - 1000) / 1_000_000.0
        ratio = max(1e-8, 1.0 + drift)
        return {
            "quoteId": f"paper-{uuid.uuid4().hex}",
            "fromAsset": from_token,
            "toAsset": to_token,
            "ratio": ratio,
            "inverseRatio": 1.0 / ratio,
            "fromAmount": float(amount),
            "toAmount": float(amount) * ratio,
            "paper": True,
        }

    return get_quote_with_id(from_token, to_token, from_amount=amount)


def accept_quote(quote_id: str, walletType: Optional[str] = None) -> Dict[str, Any]:
    if os.getenv("PAPER", "1") == "1" or os.getenv("ENABLE_LIVE", "0") != "1":
        logger.info("[dev3] DRY-RUN: acceptQuote skipped for %s", quote_id)
        return {"dryRun": True, "msg": "acceptQuote skipped in PAPER/DRY-RUN"}
    if quote_id in _accepted_quotes:
        logger.info("[dev3] Duplicate acceptQuote ignored for %s", quote_id)
        return {"duplicate": True, "quoteId": quote_id}
    _accepted_quotes.add(quote_id)
    params = {"quoteId": quote_id, "recvWindow": DEFAULT_RECV_WINDOW}
    if walletType:
        params["walletType"] = walletType
    return _request("POST", "/sapi/v1/convert/acceptQuote", params)


def get_order_status(orderId: Optional[str] = None, quoteId: Optional[str] = None) -> Dict[str, Any]:
    """Return order status by ``orderId`` or ``quoteId`` (exactly one)."""

    if (orderId is None) == (quoteId is None):
        raise ValueError("Provide exactly one of orderId or quoteId")

    params = {"orderId": orderId} if orderId is not None else {"quoteId": quoteId}
    params["recvWindow"] = DEFAULT_RECV_WINDOW
    return _request("GET", "/sapi/v1/convert/orderStatus", params)


def get_quote_status(order_id: str) -> Dict[str, Any]:
    return get_order_status(orderId=order_id)


def trade_flow(
    startTime: int,
    endTime: int,
    limit: Optional[int] = None,
    cursor: Optional[str] = None,
) -> Dict[str, Any]:
    """Wrapper for ``GET /sapi/v1/convert/tradeFlow`` endpoint.

    ``startTime`` and ``endTime`` are mandatory according to Binance docs. A
    ``ValueError`` is raised if either is omitted.
    """

    if startTime is None or endTime is None:
        raise ValueError("startTime and endTime are required")

    params: Dict[str, Any] = {
        "startTime": startTime,
        "endTime": endTime,
    }
    if limit is not None:
        params["limit"] = limit
    if cursor is not None:
        params["cursor"] = cursor
    data = _request("GET", "/sapi/v1/convert/tradeFlow", params)
    return {"list": data.get("list", []), "cursor": data.get("cursor")}


def get_all_supported_convert_pairs() -> Set[str]:
    global _supported_pairs_cache, _pairs_cache_time
    now = time.time()
    if _supported_pairs_cache is None or now - _pairs_cache_time > PAIRS_TTL:
        data = exchange_info()
        pairs: Set[str] = set()
        if isinstance(data, dict):
            for item in data.get("fromAssetList", []):
                from_asset = item.get("fromAsset")
                for to in item.get("toAssetList", []):
                    to_asset = to.get("toAsset")
                    if from_asset and to_asset:
                        pairs.add(f"{from_asset}{to_asset}")
        _supported_pairs_cache = pairs
        _pairs_cache_time = now
    return _supported_pairs_cache


def is_valid_convert_pair(from_token: str, to_token: str) -> bool:
    symbol = f"{from_token}{to_token}"
    return symbol in get_all_supported_convert_pairs()
# === FIX 2025-09-06: Binance Convert getQuote / acceptQuote ===

def _fmt_amount(amount, asset):
    # використовуємо наявний у модулі форматер, якщо він є
    f = (globals().get("_format_amount_for_asset")
         or globals().get("_norm_amount_for_asset"))
    if callable(f):
        try:
            return f(amount, asset)   # варіант (amount, asset)
        except TypeError:
            try:
                return str(f(amount)) # варіант (amount)
            except Exception:
                pass
    # базовий фолбек
    from decimal import Decimal
    return format(Decimal(str(amount)), "f")

def get_quote_with_id(
    from_asset,
    to_asset,
    from_amount=None,
    to_amount=None,
    walletType=None,
    validTime=None,
    recvWindow=None,
):
    # рівно один з from_amount/to_amount
    if (from_amount is None) == (to_amount is None):
        raise ValueError("Provide exactly ONE of from_amount or to_amount")

    # recvWindow (за замовчуванням + clamp ≤ 60000)
    if recvWindow is None:
        recvWindow = int(globals().get("DEFAULT_RECV_WINDOW",
                        globals().get("DEFAULT_RECV_WIN", 5000)))
    recvWindow = min(int(recvWindow), 60000)

    params = {
        "fromAsset": from_asset,
        "toAsset": to_asset,
        "recvWindow": recvWindow,
        # якщо ваш _request не додає timestamp автоматично — розкоментуйте:
        # "timestamp": int(__import__("time").time() * 1000),
    }
    if from_amount is not None:
        params["fromAmount"] = _fmt_amount(from_amount, from_asset)
    if to_amount is not None:
        params["toAmount"]  = _fmt_amount(to_amount,  to_asset)
    if walletType:
        params["walletType"] = walletType  # SPOT/FUNDING/EARN або їх комбінації
    if validTime:
        params["validTime"]  = validTime   # '10s' | '30s' | '1m'

    # POST /sapi/v1/convert/getQuote
    return _request("POST", "/sapi/v1/convert/getQuote", params)

def accept_quote(quote_id, recvWindow=None):
    if not quote_id:
        raise ValueError("quote_id is required")

    if recvWindow is None:
        recvWindow = int(globals().get("DEFAULT_RECV_WINDOW",
                        globals().get("DEFAULT_RECV_WIN", 5000)))
    recvWindow = min(int(recvWindow), 60000)

    params = {
        "quoteId": quote_id,
        "recvWindow": recvWindow,
        # якщо _request не додає timestamp — розкоментуйте:
        # "timestamp": int(__import__("time").time() * 1000),
    }
    # ВАЖЛИВО: walletType тут НЕ передається (за специфікацією acceptQuote)
    return _request("POST", "/sapi/v1/convert/acceptQuote", params)

# зручна обгортка, якщо десь викликається get_quote(from,to,amount)
def get_quote(from_token, to_token, amount):
    if amount is None:
        raise ValueError("amount is required")
    return get_quote_with_id(from_token, to_token, from_amount=amount)

# === /FIX ===
def _normalize_convert_response(resp):
    if not isinstance(resp, dict):
        return resp
    base = resp.get("data") or resp.get("result") or resp
    # синоніми назв
    if "quoteID" in base and "quoteId" not in base:
        base["quoteId"] = base["quoteID"]
    if "convertRatio" in base and "price" not in base:
        base["price"] = base["convertRatio"]
    # уніфікуємо типи в str для логування/порівнянь
    for k in ("fromAmount","toAmount","price"):
        if k in base and base[k] is not None:
            base[k] = str(base[k])
    return base

# обгорнемо повернення наших функцій нормалізатором
_old_get_quote_with_id = get_quote_with_id
def get_quote_with_id(*a, **kw):
    return _normalize_convert_response(_old_get_quote_with_id(*a, **kw))

_old_accept_quote = accept_quote
def accept_quote(*a, **kw):
    return _normalize_convert_response(_old_accept_quote(*a, **kw))
import logging as _lg
_log = _lg.getLogger(__name__)

_old_accept_quote_dbg = accept_quote
def accept_quote(*a, **kw):
    try:
        resp = _old_accept_quote_dbg(*a, **kw)
        if isinstance(resp, dict) and not resp.get("orderId"):
            _log.warning("accept_quote: no orderId in response: %s", resp)
        return resp
    except Exception as e:
        _log.exception("accept_quote failed: %r", e)
        raise
# === Helper: try multiple walletType to obtain quoteId (per Binance Convert docs) ===
def get_quote_with_id_try_wallets(
    from_asset, to_asset, *,
    from_amount=None, to_amount=None,
    wallets=((None,'SPOT','FUNDING','EARN','SPOT_FUNDING','FUNDING_EARN','SPOT_FUNDING_EARN','SPOT_EARN')),
    validTime="10s", recvWindow=None, **kw
):
    """
    Повертає першу відповідь, у якій є quoteId. Якщо ніде не вистачає коштів —
    повертає останню відповідь (для діагностики).
    """
    last = None
    for w in wallets:
        try:
            resp = get_quote_with_id(
                from_asset, to_asset,
                from_amount=from_amount, to_amount=to_amount,
                walletType=w, validTime=validTime, recvWindow=recvWindow, **kw
            )
        except Exception as e:
            last = {"walletType": w, "error": str(e)}
            continue
        if isinstance(resp, dict) and resp.get("quoteId"):
            resp["walletType"] = w
            return resp
        last = resp if resp else {"walletType": w}
    return last



# === Convert: exchange info helpers ===
def get_convert_pairs():
    """
    Обгортає /sapi/v1/convert/exchangeInfo.
    Повертає те, що віддає Binance (dict або list) як є.
    """
    return _request("GET", "/sapi/v1/convert/exchangeInfo", {})

def get_convert_pair_info(from_asset: str, to_asset: str):
    """
    Витягнути інформацію по конкретній парі (from_asset -> to_asset)
    із exchangeInfo. Повертає dict або None.
    """
    data = get_convert_pairs()
    items = data if isinstance(data, list) else (data.get("data") or data.get("symbols") or data)
    if not isinstance(items, (list, tuple)):
        return None
    from_a, to_a = (str(from_asset or '').upper(), str(to_asset or '').upper())
    for it in items:
        fa = str(it.get("fromAsset", it.get("baseAsset", ""))).upper()
        ta = str(it.get("toAsset", it.get("quoteAsset", ""))).upper()
        if fa == from_a and ta == to_a:
            return it
    return None
